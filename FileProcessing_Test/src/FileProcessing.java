package com.ibm.acecc;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;
import com.ibm.integration.test.v1.NodeSpy;
import com.ibm.integration.test.v1.NodeStub;
import com.ibm.integration.test.v1.TestMessageAssembly;
import com.ibm.integration.test.v1.TestSetup;
import com.ibm.integration.test.v1.exception.TestException;
import com.ibm.util.CommonUtil;
import static com.ibm.integration.test.v1.Matchers.*;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

import java.io.File;
import java.io.IOException;
import java.util.Properties;

public class FileProcessing extends CommonUtil {

	/*
	 * CustomerManagement_getModifyCustomer_subflow_0001_Test
	 * Test generated by IBM App Connect Enterprise Toolkit 12.0.3.0 on 25 Jul, 2022 6:07:56 PM
	 */

	@AfterEach
	public void cleanupTest() throws TestException {
		// Ensure any mocks created by a test are cleared after the test runs 
		TestSetup.restoreAllMocks();
	}

	@Test
	public void CustomerManagement_getModifyCustomer_subflow_TestCase_001() throws TestException {
		try {
		String propertyFileName = null;
		String dirName = System.getProperty("user.dir");
		File directory = new File(dirName);
		File[] fileList = directory.listFiles();
		for(File file :  fileList) {
			if(file.getName().contains(".properties")) {
				propertyFileName = file.getName().toString();
				System.out.println("Filename-->"+propertyFileName);
				
				//Define TestMessage Assembly
				TestMessageAssembly actualMessageAssembly,actualMessageAssembly2 = null,computeActualMessageAssembly,computeAssembly,compute2Assembly = null;
				NodeSpy spyInput,spyOut = null;
				CommonUtil util = new CommonUtil();
				Properties prop = util.readProperties(propertyFileName);
				
				//Getting nodespy for input node on subflow
				spyInput = getNodeSpy("input",propertyFileName);
				computeAssembly = getMesgAssembly("input",propertyFileName);
				
				//Getting nodespy for output node on subflow
				spyOut = getNodeSpy("output",propertyFileName);
				TestMessageAssembly compute1Assembly = getMesgAssembly("output",propertyFileName);
				if(prop.getProperty("isMultiPropagate").equals("Y")) {
					compute2Assembly = getMesgAssembly("propagate",propertyFileName);
				}
				//spyOut.setStopAtInputTerminal("in");
				
				//Getting nodespy for stub node on subflow
				if(prop.getProperty("isStub").equals("Y")) {
				NodeStub stub = getNodeStub("stub",propertyFileName);
				TestMessageAssembly stubAssembly = getMesgAssembly("stub",propertyFileName);
					if(prop.getProperty("isAgg").equals("Y")) {
					//Using stub message in the place of original request call
						stub.onCall().propagatesMessage(null, "out", stubAssembly);
					}else {
					stub.onCall().propagatesMessage("in", "out", stubAssembly);
					}
				//stub.setStopAtOutputTerminal("out");
				}
				
				//Processing of message flow starts from here
				spyInput.propagate(computeAssembly, "out");
				
				//Compare request message
				if(!prop.getProperty("isNormalFlow").equals("Y")) {
				computeActualMessageAssembly = spyInput.propagatedMessageAssembly("out",1);
				assertThat(computeActualMessageAssembly, equalsMessage(computeAssembly));
				System.out.println("Compute input message validated");
				}
	
				//Getting actual message from output
				assertThat(spyOut, nodeCallCountIs(1));
				actualMessageAssembly = spyOut.propagatedMessageAssembly("out", 1);
				if(prop.getProperty("isMultiPropagate").equals("Y")) {
					actualMessageAssembly2 = spyOut.propagatedMessageAssembly("out1", 1);
				}
				// Assert the Compute node is called and that the expected message is returned
				
				//Compare actual message with testmessage
				assertThat(actualMessageAssembly, equalsMessage(compute1Assembly));
				System.out.println("First output message validated");
				if(prop.getProperty("isMultiPropagate").equals("Y")) {
					assertThat(actualMessageAssembly2, equalsMessage(compute2Assembly));
					System.out.println("Second output message validated");
				}
				
				//Error Handling
				/*TestMessageAssembly emptyTestMessageAssembly = new TestMessageAssembly();
				TestException propagateEx = assertThrows(TestException.class, () -> {
					spyInput.propagate(emptyTestMessageAssembly, "in");
				});
					
				assertThat(propagateEx, causedBy(hasMessageNumber(2666),
                        containsMessageText("Unable to open Folder"),
                        containsMessageText("Input")));*/
			   }
		}

		} catch (TestException | IOException ex) {
			throw new TestException("Number of propagated messages is 0 but you asked for number 1");
		}
	}
}
